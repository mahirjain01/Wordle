{"ast":null,"code":"/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto'; // Cast array to different type\n\nexport const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)); // Cast array to view\n\nexport const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength); // The rotate right (circular right shift) operation for uint32\n\nexport const rotr = (word, shift) => word << 32 - shift | word >>> shift;\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44; // There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\n\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\n\nexport function bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\n\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n} // There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\n\nexport const nextTick = async () => {}; // Returns control to thread each 'tick' ms to avoid blocking\n\nexport async function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n\n  for (let i = 0; i < iters; i++) {\n    cb(i); // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n\n  return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\n\nexport function concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n} // For runtime check if class implements interface\n\nexport class Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n\n} // Check if object doens't have custom constructor (like Uint8Array/Array)\n\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\nexport function checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = () => hashConstructor();\n\n  return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = opts => hashCons(opts);\n\n  return hashC;\n}\n/**\n * Secure PRNG\n */\n\nexport function randomBytes() {\n  let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n  if (crypto.web) {\n    return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto.node) {\n    return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}","map":{"version":3,"sources":["/home/mahir/INTER-IIT/wordle/node_modules/@noble/hashes/esm/utils.js"],"names":["crypto","u8","arr","Uint8Array","buffer","byteOffset","byteLength","u32","Uint32Array","Math","floor","createView","DataView","rotr","word","shift","isLE","Error","hexes","Array","from","length","v","i","toString","padStart","bytesToHex","uint8a","hex","hexToBytes","TypeError","array","j","hexByte","slice","byte","Number","parseInt","isNaN","nextTick","asyncLoop","iters","tick","cb","ts","Date","now","diff","utf8ToBytes","str","TextEncoder","encode","toBytes","data","concatBytes","arrays","every","a","reduce","result","pad","set","Hash","clone","_cloneInto","isPlainObject","obj","Object","prototype","call","constructor","checkOpts","defaults","opts","undefined","merged","assign","wrapConstructor","hashConstructor","hashC","message","update","digest","tmp","outputLen","blockLen","create","wrapConstructorWithOpts","hashCons","msg","randomBytes","bytesLength","web","getRandomValues","node"],"mappings":"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","sourcesContent":["/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n"]},"metadata":{},"sourceType":"module"}