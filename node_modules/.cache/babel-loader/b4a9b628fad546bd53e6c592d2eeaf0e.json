{"ast":null,"code":"\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0; // Utilities\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\n\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\nfunction chain() {\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a, b) => c => a(b(c)); // Construct chain of args[-1].encode(args[-2].encode([...]))\n\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, undefined); // Construct chain of args[0].decode(args[1].decode(...))\n\n  const decode = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, undefined);\n  return {\n    encode,\n    decode\n  };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction alphabet(alphabet) {\n  return {\n    encode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(i => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i];\n      });\n    },\n    decode: input => {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(letter => {\n        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction join() {\n  let separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: from => {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n\n      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n\n      return from.join(separator);\n    },\n    decode: to => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction padding(bits) {\n  let chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n\n      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n\n      while (data.length * bits % 8) data.push(chr);\n\n      return data;\n    },\n\n    decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n\n      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n\n      let end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n\n      return input.slice(0, end);\n    }\n\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: from => from,\n    decode: to => fn(to)\n  };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction convertRadix(data, from, to) {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach(d => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n\n  while (true) {\n    let carry = 0;\n    let done = true;\n\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i];\n      const digitBase = from * carry + digit;\n\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n\n      carry = digitBase % to;\n      const rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!rounded) pos = i;else done = false;\n    }\n\n    res.push(carry);\n    if (done) break;\n  }\n\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n\n  return res.reverse();\n}\n\nconst gcd =\n/* @__NO_SIDE_EFFECTS__ */\n(a, b) => !b ? a : gcd(b, a % b);\n\nconst radix2carry =\n/*@__NO_SIDE_EFFECTS__ */\n(from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n\n  if (radix2carry(from, to) > 32) {\n    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n  }\n\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n\n  const mask = 2 ** to - 1;\n  const res = [];\n\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = carry << from | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n\n    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n\n    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n  }\n\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    }\n  };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction radix2(bits) {\n  let revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function () {\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n\n    decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n\n      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n\n      return payload;\n    }\n\n  };\n}\n\nexports.utils = {\n  alphabet,\n  chain,\n  checksum,\n  radix,\n  radix2,\n  join,\n  padding\n}; // RFC 4648 aka RFC 3548\n// ---------------------\n\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join('')); // base58 code\n// -----------\n\nconst genBase58 = abc => chain(radix(58), alphabet(abc), join(''));\n\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'); // xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\n\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n  encode(data) {\n    let res = '';\n\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n\n    return res;\n  },\n\n  decode(str) {\n    let res = [];\n\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = exports.base58.decode(slice);\n\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n\n    return Uint8Array.from(res);\n  }\n\n};\n\nconst base58check = sha256 => chain(checksum(4, data => sha256(sha256(data))), exports.base58);\n\nexports.base58check = base58check;\nconst BECH_ALPHABET = /* @__PURE__ */chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\nfunction bech32Polymod(pre) {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n\n  return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction bechChecksum(prefix, words) {\n  let encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const len = prefix.length;\n  let chk = 1;\n\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n\n  chk = bech32Polymod(chk);\n\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\n\n\nfunction genBech32(encoding) {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n\n  const _words = radix2(5);\n\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode(prefix, words) {\n    let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;\n    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n  }\n\n  function decode(str) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;\n    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`); // don't allow mixed case\n\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n    str = lowered;\n    const sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = str.slice(0, sepIndex);\n\n    const _words = str.slice(sepIndex + 1);\n\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return {\n      prefix,\n      words\n    };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str) {\n    const {\n      prefix,\n      words\n    } = decode(str, false);\n    return {\n      prefix,\n      words,\n      bytes: fromWords(words)\n    };\n  }\n\n  return {\n    encode,\n    decode,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords\n  };\n}\n\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n  encode: data => new TextDecoder().decode(data),\n  decode: str => new TextEncoder().encode(str)\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n  return s.toLowerCase();\n})); // prettier-ignore\n\nconst CODERS = {\n  utf8: exports.utf8,\n  hex: exports.hex,\n  base16: exports.base16,\n  base32: exports.base32,\n  base64: exports.base64,\n  base64url: exports.base64url,\n  base58: exports.base58,\n  base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\nconst bytesToString = (type, bytes) => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\n\nconst stringToBytes = (type, str) => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;","map":{"version":3,"sources":["/home/mahir/INTER-IIT/wordle/node_modules/@scure/base/lib/index.js"],"names":["Object","defineProperty","exports","value","bytes","stringToBytes","str","bytesToString","hex","utf8","bech32m","bech32","base58check","base58xmr","base58xrp","base58flickr","base58","base64urlnopad","base64url","base64","base32crockford","base32hex","base32","base16","utils","assertNumber","n","Number","isSafeInteger","Error","chain","wrap","a","b","c","args","encode","Array","from","reverse","reduce","acc","i","undefined","decode","alphabet","digits","isArray","length","map","input","letter","index","indexOf","join","separator","to","split","padding","bits","chr","data","push","end","slice","normalize","fn","convertRadix","pos","res","forEach","d","carry","done","digit","digitBase","rounded","Math","floor","gcd","radix2carry","convertRadix2","mask","radix","num","Uint8Array","radix2","revPadding","unsafeWrapper","apply","e","checksum","len","set","payload","newChecksum","oldChecksum","s","toUpperCase","replace","genBase58","abc","XMR_BLOCK_LEN","block","subarray","padStart","blockLen","j","concat","sha256","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","actualLength","TypeError","lowered","toLowerCase","sum","sepIndex","lastIndexOf","endsWith","decodeUnsafe","decodeToBytes","TextDecoder","TextEncoder","CODERS","coderTypeError","type","hasOwnProperty"],"mappings":"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","sourcesContent":["\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n"]},"metadata":{},"sourceType":"script"}