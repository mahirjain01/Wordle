{"ast":null,"code":"import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js'; // Polyfill for Safari 14\n\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n\n  const _32n = BigInt(32);\n\n  const _u32_max = BigInt(0xffffffff);\n\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n} // Base SHA2 class (RFC 6234)\n\n\nexport class SHA2 extends Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n\n  update(data) {\n    assert.exists(this);\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos); // Fast path: we have at least one block in input, cast it to view and process\n\n      if (take === blockLen) {\n        const dataView = createView(data);\n\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n\n        continue;\n      }\n\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n\n  digestInto(out) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true; // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this; // append the bit '1' to the message\n\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0); // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    } // Pad until full block byte with zeros\n\n\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0; // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n\n\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n  }\n\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n\n}","map":{"version":3,"sources":["/home/mahir/INTER-IIT/wordle/node_modules/@noble/hashes/esm/_sha2.js"],"names":["assert","Hash","createView","toBytes","setBigUint64","view","byteOffset","value","isLE","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","SHA2","constructor","blockLen","outputLen","padOffset","finished","length","pos","destroyed","buffer","Uint8Array","update","data","exists","len","take","Math","min","dataView","process","set","subarray","roundClean","digestInto","out","output","fill","i","oview","get","forEach","v","digest","res","slice","destroy","_cloneInto","to"],"mappings":"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","sourcesContent":["import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        assert.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}